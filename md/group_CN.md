	群组聊天在tox中通过临时添加一些对等节点(最多四个)工作,在当前群组聊天中,作为临时friend_connection 好友, 在退出群组聊天的时候,它们会被删除.

	在群组中,每一个对等节点是通过它们的真实的长期公钥被标识,然而对等节点通过群组聊天给每一个节点,传输它们的DHT公钥,为了让它为每个节点通过onion,找到其它节点的DHT公钥不是必须的,来加速连接, 如果它们可以添加它们自己作为正常的好友,这可能发生.

	使用friend_connections的好处是,群组聊天不像“打洞”那样处理事情.对等节点只有tcp或者其它低级的网络事务.然而缺点是每一个单独的对等节点都知道其它节点的真实的长期公钥和DHT公钥,这就意味着群组聊天应该只被用于好友之间.

	为了互相连接,两个节点必须将对方添加到它们的好友连接列表中.如果群组聊天的参与者数量等于或者小于5的时候,这不是一个问题.例如5个对等节点,每一个都将会将其它4个对等节点,添加到它们的好友链接列表中.当有更多的节点的时候,必须有一种方法,确保对等节点将会设法连接到其它群组中的对等节点.

	尽管每个群组中,通过好友链接到的最大节点的数量是4,如果在群组中所有的的对等节点都被放在一个正环中,每个对等节点连接离它们右边最近的两个对等节点和离它们最近的左边的两个节点,这些对等节点应该形成了一个连接良好的对等节点环.

	在toxcore,群组聊天通过减去在群组中的其它对等节点的真实长期公钥(our pk - other peer PK),且做最小的操作,找到两个对等节点.操作是增长的(other peer pk - our pk),在群组中,这个操作在一次对所有对等节点的公钥执行.选择结果中最小的两个节点.

	这个给出4个对等节点,然后被添加到好友连接并关联到组.如果在群组中每个对等节点都这样做,它们将会形成一个完美连接节点环.

	一旦对等节点在环中连接其它的节点,它们给每个其它的节点,重放信息.每次一个节点离开群组或者一个新的节点加入群组,聊天的每一个成员,都将会重新计算它们应该连接的节点.

	节点必须是首次被它们的好友邀请加入群组聊天.要生成聊天群组,节点将首次创建群组,然后邀请人加入这个群组.一旦它们的好友在群组中,它们可以邀请它们其它的朋友加入这个聊天组,等等.

	创建一个聊天组,节点将会产生一个随机32字节的ID,这个id被当做这个聊天组的唯一标识.当用安全随机数生产器生成随机数, 每个群组会创建不同的id,32字节是足够用.32字节id的目标是那个节点识别每个群组聊天的方法,以便于它们可以阻止它们自己加入一个群组两次

	聊天群组也有一个无符号的一字节类型.这个类型标识了聊天群组的种类 当前类型是 0 text, 1 audio

	0: text
	1: audio 

	文本群聊是只有文本,当有audio标识,在群组中发送audio时,它也会被当做文本.

	群聊将会被唯一的无符号的2字节int类型标识.在toxcore,它对应存储在数组的对应的群聊的索引.在当前的实例中,每个群聊必须有不同的号码.这个号码被群聊节点用来直接连接我们和告诉我们,哪个包来自于哪个聊天组.这也是为什么每个群聊包,包含群聊号码作为它们的一部分.在每个包中存放32字节群聊的id,会增加带宽的浪费,这就是为什么用群聊号码代替它的原因.

	使用群聊号码作为数组的索引,被用来存储群聊实例,这种方法是被推荐的.因为这种可以很有效访问,且它确保每个群组具有唯一的群组号码.
	
	当创建一个新的群聊的时候,对等节点将会添加它们自己作为群组的对等节点,且节点号码为0.它们拥有长期公钥和DHT公钥.

	Invite packets:
	Invite packet:
	[uint8_t id 96][uint8_t id 0][uint16_t group number][33 bytes group chat identifier[1 byte type][32 bytes id]]

	Response packet
	[uint8_t id 96][uint8_t id 1][uint16_t group number(local)][uint16_t group chat number to join][33 bytes group chat identifier[1 byte type][32 bytes id]]

	邀请包发送给好友,邀请好友加入群组聊天.这些包通过消息管理器发送(如果你看过消息管理包id片段,会看到所有的群聊包ids都在里面).请注意,使用tox 包发送的所有号码都以big endian格式发送.

	综上所述,群聊号码被用来作为所有的其它的群聊实例节点的唯一标识.因为它被好友需要,为了发送返回群聊涉及到的包,所以它在邀请包里面发送.

	跟随1字节类型和32字节群聊id添加到它里面.

	拒绝邀请,好友收到它将会简单的忽略和丢弃它.

	接受邀请,好友将会在请求中,用32字节群聊id和1字节类型,创建它们自己群聊实例, 发送邀请响应包返回.也将会把发送邀请的节点作为一个临时邀请的群聊链接,添加为好友.

	在响应包中的第一组群号码,是在邀请好友时被创建的组号码.第二个组号码是被发送在邀请请求中的群聊号码.

	以下是,在邀请请求中的,1字节类型和32字节群聊id.

	当一个节点接受一个邀请响应包, 它们将会检查发回的群id是否对应返回的群号码的群id.如果每一个都是ok的, 一个新的节点号码将会为这个发送邀请响应包的节点生成.然后节点和它们生成的节点号码,它们长期公钥和DHT公钥将会被添加到群组的节点列表.关于新节点的节点包将会被发送给群组中的每一个节点.节点也会作为临时邀请群组连接被添加到节点列表中.

	在群聊中,节点号码被用于每个节点的唯一标识.它们被用于每个群聊信息包中,以便于节点接收它们,可以知道是谁或者哪一个群聊节点发送的它们.作为群聊包是被重放的, 它们必须包含一些被用于其它人来标识发送者的东西.因为在每个包里存放32字节公钥,十分浪费,所以用2字节节点号码代替.在群组中,每个节点有唯一的节点号码.toxcore 随机生成每一个节点号码 但是确保新生成的节点号码不等于当前已经被其它节点使用的号码.在群聊中.如果两个节点通过两个不同的端点加入群聊 ,它很小可能会给相同节点号码,这个可能在实践中,非常低, 所以这不是一个问题.

	临时邀请群聊连接是群聊邀请者的群聊连接,被群聊节点引导它们自己加入群聊.作为到群聊节点的连接,它们和通过好友连接一样,除了节点满了之后,连接群聊,它们会被丢弃.

	Peer online packet:
	[uint8_t id 97][uint16_t group number (local)][33 bytes group chat identifier[1 byte type][32 bytes id]]

	Peer leave packet:
	[uint8_t id 98][uint16_t group number][uint8_t id 1]

	要是聊天群组链接工作, 在群聊中,两个节点必须尝试直接连接对方.

	当两个想要互相连接彼此的节点,创建一个新的好友连接,来连接对方或者重用一个已经存在的好友连接,来把它们连接在一起的时候,群聊连接被建立.如果它们是好友或者已经因为另一个群组聊天连接在一起) 

	一旦对其它节点的连接被打开的,一个节点online包发送给其它节点.online包的目的是告诉其它的节点,我们想和它们建立群聊连接,并告诉它们,我们群聊实例的群号码.节点online包包含群号码和群类型和32字节的群聊id.群号码是节点发送的群的群id对应的群号码.

	当两个端都给对方发送online包,链接被建立.

	当online包被接收, 将保存和群有联系的群号码.如果对节点连接是已经建立的(an online包已经被接收)然后包会被丢弃.如果对节点的群连接没有建立,包会被丢弃.如果这是我们首次对那个群建立群连接,节点查询包被发送.所以我们可以得到群的所有节点的列表.

	一个节点离开包,在连接中断之前,发送给节点.如果有好友连接被用于其它的群聊(另一个群聊, 对好友的链接)它只被用于告诉其它端,链接被终止.如果没有,其它节点将会看到好友连接下线,提示它们停止使用它,并且终止群连接对它的绑定.

	Peer query packet:
	[uint8_t id 98][uint16_t group number][uint8_t id 8]

	Peer response packet:
	[uint8_t id 98][uint16_t group number][uint8_t id 9][Repeated times number of peers: [uint16_t peer num][uint8_t 32bytes real public key][uint8_t 32bytes temp DHT public key][uint8_t name length][name]] 

	Title response packet:
	[uint8_t id 98][uint16_t group number][uint8_t id 10][title]

	Message packets:
	[uint8_t id 99][uint16_t group number][uint16_t peer number][uint32_t message number][uint8_t with a value representing id of message][data]

	Lossy Message packets:
	[uint8_t id 199][uint16_t group number][uint16_t peer number][uint16_t message number][uint8_t with a value representing id of message][data]

	这就是节点加入群组聊天之后,找到群组聊天中的节点列表,和群组聊天的标题.
	节点响应包是直接响应的,包含信息给每一个节点(节点号码, 真实公钥 DHT公钥和名字)追加给每一个节点.标题响应也是直接响应.

	群聊节点的名字的最大长度和群聊的标题是128字节.这是所有名字在toxcore中的最大长度.

	当一个节点接收节点响应包的时候,它们将会添加每一个接收节点到它们的群聊节点列表,找到离它们最近的4个节点, 给它们创建群聊连接,像前面的阐述.

	找到它们的节点号码,节点将会在接收的节点列表中找到它们自己,并使用节点号码代表它们自己.
	
	在群聊中,消息包被用来给所有的节点发送消息.发送一个消息包,一个节点将首先拿到它们的节点号码,和它们想要发送的消息.每个消息包将发送一个有消息号码,消息号码等于它最后一次发送消息号码+1.在包中,像所有号码(群聊号码,节点号码)一样,消息号码将会用big endian格式发送.当消息包被接收,节点接收它,将会拿到包中的消息号码,查看它是否是大于它为这个节点保存的号码.如果这是这个节点首个被接收的消息包,检查是被省略的.消息号码被用来判断是否消息包已经被接收和重放,阻止来自群聊中的循环包 ,如果消息号码检查说 包已经被接收,包将被丢弃.如果它没有被被接收,消息包将会和消息发送(relayed)给当前群聊连接(normal groupchat connections + temporary invited groupchat connections),除了它接收的连接.消息包中唯一一个应该改变的事情是它的重放的群号码.

	message ids:
	0 - ping
	sent every ~60 seconds by every peer.
	No data.

	16 - new_peer
	Tell everyone about a new peer in the chat.
	[uint16_t peer_num][uint8_t 32bytes real public key][uint8_t 32bytes temp DHT public key]

	17 - kill_peer
	[uint16_t peer_num]

	48 - name change
	[uint8_t name[namelen]]

	49 - groupchat title change
	[uint8_t title[titlelen]]

	64 - chat message
	[uint8_t message[messagelen]]

	65 - action (/me)
	[uint8_t message[messagelen]]

	ping消息必须每隔60秒被每个节点发送.这也是怎么知道其它的节点依旧存活的方法.

	当一个新的节点加入,它将会发送新节点消息给每一个节点,通知它们,有新的节点加入聊天.当新的节点消息被接收,包中的节点必须被添加到节点列表中.

	结束节点消息被用来标识节点退出群聊.在它们退出群聊之前,它发送qutting.

	名字改变消息被用来改变或者设置名字的节点的发送它.加入的节点在接收到节点列表之后,也会发送它们,以便告诉其它节点,它们的名字是什么.

	标题更改包被用于改变群聊标题,群组中何一个节点都可以发送它.

	聊天和动作消息,被群组节点发送给在群聊中其它的节点.

	在audio群聊中,有损失消息包被用来给其它的节点发送语音包.有损包工作方法,像正常的群聊消息重放一样,它们给群聊中每一个节点重放,直到它们都接收到它.

	它们有一些不同,首先所有的消息号码开头是2字节整数, 如果我改进群聊协议,我可以为每个正常的消息包,制作2字节消息号码.1字节意味着只有256包在相同的时间被接收.由于群聊和256个分组中的延迟对应于小于高质量视频帧,所以它不工作.这就是为什么选择2个字节.

	在包中,记录消息号码像所有的其它号码一样,是big endian格式.

	当接收有损包,节点将会首先检查它是否已经被接收.如果没有,包将会被添加到接受包列表中 ,然后包将会被传递给它的处理器 和把它发送给在群聊节点中,不是发送者的最近的2个连接节点.用2而不用4的原因是(如果我们不是原始的发送者,3很好),对于正常消息包它减少了带宽的使用,而没有通过有损包降低接收到的语音流的质量.消息包也比较少发送,改变它为2,足够可以有一个小的带宽使用的影响.

	检查包是否被接收了,最多有65536接收的包号码被存储,当前群组存储256包号码,然而这是因为它当前只是语音.如果视频被添加,意味着更高的包数量被发送,号码可能会增加.如果包号码在列表中,表示它被接收了.

	这就是群聊在tox中是怎样工作的.

